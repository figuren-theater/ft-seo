<?php
/**
 * Figuren_Theater SEO Sharing_Image\Generation.
 *
 * @package figuren-theater/ft-seo
 */

namespace Figuren_Theater\SEO\Sharing_Image\Generation;

use Figuren_Theater\Media\Image_Optimization;
use Figuren_Theater\SEO\Sharing_Image;
use Sharing_Image\Generator;
use Sharing_Image\Widget;
use WP_Post;
use function add_action;
use function add_filter;
use function did_action;
use function do_action;
use function esc_url;
use function get_attached_file;
use function get_option;
use function get_post;
use function get_post_meta;
use function get_post_parent;
use function get_post_thumbnail_id;
use function get_post_type;
use function post_type_supports;
use function site_url;
use function wp_get_shortlink;
use function wp_get_upload_dir;
use function wp_installing;
use function wp_is_post_revision;
use function wp_parse_url;
use function sanitize_url;
use function untrailingslashit;

const LAYER = [
	'title'   => 0,
	'logo'    => 1,
	'url'     => 2,
	'overlay' => 3,
	'blur'    => 4,
];

/**
 * Bootstrap module, when enabled.
 *
 * @return void
 */
function bootstrap(): void {
	add_action( 'init', __NAMESPACE__ . '\\load', 0 ); // Figuren_Theater\Media\Auto_Featured_Image runs on 'init:10'.
}

/**
 * Load Autogeneration logic hooks at relevant spots of the save_post workflow.
 *
 * @return void
 */
function load(): void {

	// BACKEND | Autogeneration logic triggered on 'wp_insert_post'.

	// Delete post_meta to allow for proper autogenerate poster if it is needed.
	add_action( 'wp_insert_post', __NAMESPACE__ . '\\prepare_autogenerate_poster', 0, 3 ); // The plugin runs on 10.

	// Update static, with more dynamic, site-specific options.
	add_filter( 'pre_option_sharing_image_templates', __NAMESPACE__ . '\\pre_option_sharing_image_templates', 20 );

	// Re-Enables default functionality
	// of using the featured-image as background-image
	// which is not happening reliable on autogeneration.
	add_filter( 'sharing_image_prepare_template', __NAMESPACE__ . '\\sharing_image_prepare_template', 10, 2 );

	// Shrink new image and delete previous image.
	add_filter( 'sharing_image_autogenerated_poster', __NAMESPACE__ . '\\optimize_new_delete_previous_image', 10, 2 );

	add_filter( 'sharing_image_disable_autogeneration', __NAMESPACE__ . '\\maybe_disable_autogeneration', 10, 2 );

	// Re-Enables default func.
	// of using the featured-image as background-image
	// which is not happening reliable on autogeneration.
	// 
	// Super buggy!
	// add_action( 'updated_post_meta', __NAMESPACE__ . '\\trigger_autogeneration', 10, 4 );  // !

	// Delete auto-generated 'Sharing Image's.
	add_action( 'before_delete_post', __NAMESPACE__ . '\\delete_generated_image', 10, 2 );
}


/**
 * Delete previous image & post_meta on every 'wp_insert_post'.
 * 
 * @param int      $post_id Post ID.
 * @param \WP_Post $post Post object.
 * @param bool     $update Whether this is an existing post being updated.
 *
 * @return void
 */
function prepare_autogenerate_poster( int $post_id, WP_Post $post, bool $update ): void {
	// There could be nothing to delete,
	// on a new post.
	if ( ! $update ) {
		return;
	}

	// Make sure this runs only once.
	do_action( __NAMESPACE__ . '\\delete_generated_image' );
	if ( ! did_action( __NAMESPACE__ . '\\delete_generated_image' ) ) {
		delete_generated_image( $post_id, $post );
	}
}


/**
 * Normally the 'sharing_image_disable_autogeneration' filter is used to disable posters autogeneration process based on Post ID.
 * It could also be used to skip autogeneration for some post types.
 * 
 * @see https://wpset.org/sharing-image/hooks/#sharing_image_disable_autogeneration
 *
 * @param bool $disable_autogeneration Set true to disable autogeneration.
 * @param int  $post_id                Post ID.
 * 
 * @return bool
 */
function maybe_disable_autogeneration( bool $disable_autogeneration, int $post_id ): bool {
	if ( wp_installing() ) {
		return true;
	}


	// Make sure meta is got for the post, not for its revision.
	if ( wp_is_post_revision( $post_id ) ) {
		$post_parent = get_post_parent( $post_id );
		if ( null !== $post_parent ) {
			$post_id = $post_parent->ID;
		}
	}

	// Support Typesafety.
	$post_pt = get_post_type( $post_id );
	if ( false === $post_pt ) {
		return true;
	}

	if ( ! post_type_supports( $post_pt, Sharing_Image\POST_TYPE_SUPPORT ) ) {
		return true;
	}

	// Go on, nothing to see here.
	return $disable_autogeneration;
}


/**
 * Enhanced version of get_post() 
 * which also looks for the post-ID in the requested URL of a REST API call, if one occured.
 *
 * @return WP_Post|false
 */
function try_to_get_post(): WP_Post|false {
	
	$post = get_post();
	if ( $post instanceof WP_Post ) {
		return $post;
	}

	if ( ! isset( $_SERVER['REQUEST_URI'] ) || ! \is_string( $_SERVER['REQUEST_URI'] ) ) {
		return false;
	}

	$url_parts = wp_parse_url( sanitize_url( $_SERVER['REQUEST_URI'] ) );
	if ( ! isset( $url_parts['path'] ) ) {
		return false;
	}   

	$is_json_route = ( 0 === strpos( $url_parts['path'], '/wp-json/wp/v2/posts/' ) );
	if ( false === $is_json_route ) {
		return false;
	}
	
	$post_id = (int) str_replace(
		'/wp-json/wp/v2/posts/',
		'',
		untrailingslashit( $url_parts['path'] )
	);

	$post = get_post( $post_id );
	if ( $post instanceof WP_Post ) {
		return $post;
	}

	return false;
}

/**
 * Filters the value of the 'sharing_image_templates' option before it is retrieved.
 * 
 * This allows us to add all automated layers on the fly, when a new image is created and this option is used by WordPress.
 * 
 * Because this is a 'pre_option' filter, this needs some data. 
 * The data could come either from the options table or from our OptionsFactory filter.
 *
 * @param  array<int, mixed>|bool $option The full option 'sharing_image_templates' array.
 *
 * @return array<int, mixed>|bool
 */
function pre_option_sharing_image_templates( $option ): array|bool {

	// When this original option is set
	// during SiteSetup or within our weekly cron job
	// this filter should return false.
	if ( ! is_array( $option ) || ! isset( $option[0] ) || ! is_array( $option[0] ) ) {
		return $option;
	}

	$post = try_to_get_post();
	if ( false === $post ) {
		return false;
	}

	$template  = $option[0];
	$template  = get_site_logo( $template );
	$template  = get_theme_color( $template );
	$template  = get_featured_image( $template, $post );
	$template  = get_shortlink( $template, $post );
	$option[0] = $template;

	return $option;
}

/**
 * Prepare template before creating poster with this filter.
 * Used to update fieldset texts and background image. 
 * 
 * @see https://wpset.org/sharing-image/hooks/#sharing_image_prepare_template
 *
 * @param array<string, mixed>      $template  List of template data.
 * @param array<string, mixed>|null $fieldset  Fieldset data from picker.
 *
 * @return array<string, mixed>
 */
function sharing_image_prepare_template( array $template, array|null $fieldset ): array {

	// 0.
	if ( isset( $template['image'] ) && \is_string( $template['image'] ) && \esc_url( $template['image'] ) ) {
		return $template;
	}

	// 1.'generate_template()' @ plugins\sharing-image\classes\class-generator.php.
	$thumbnail_id = get_post_thumbnail_id();
	if ( ! empty( $thumbnail_id ) ) {
		$fieldset['attachment'] = $thumbnail_id;
	}

	// 2.'prepare_template()' @ plugins\sharing-image\classes\class-generator.php.
	if ( ! empty( $fieldset['attachment'] ) && \is_int( $fieldset['attachment'] ) ) {
		$template['image'] = get_attached_file( $fieldset['attachment'] );
	}

	return $template;
}


/**
 * Delete previous, old autogenerated-image
 * to save disk-space
 *
 * The 'sharing_image_autogenerated_poster' filter normally
 * "Filters autogenerated poster data."
 * 
 * @see https://wpset.org/sharing-image/hooks/#sharing_image_autogenerated_poster
 *
 * but we can use it to check,
 * if we have a new image
 * and if so, delete the old one.
 *
 * @since Sharing_Image 2.0.11
 *
 * @param array<string, int|string>|false $poster  Poster image, width and height data or false if undefined.
 * @param int                             $post_id Post ID.
 * 
 * @return array<string, int|string>|false
 */
function optimize_new_delete_previous_image( array|false $poster, int $post_id ): array|false {
	// Return early, if we have no new image.
	if ( false === $poster || ! isset( $poster['poster'] ) || ! \is_string( $poster['poster'] ) || ! esc_url( $poster['poster'] ) ) {
		return $poster;
	}

	// Compress image,
	// this makes 25kb > 15kb and 93kb > 49kb !
	$_path = get_path_from_url( $poster['poster'] );
	Image_Optimization\replace( $_path );

	// Grab the last image from post_meta,
	// before it gets updated
	// which happens directly after this filter
	// @plugins\sharing-image\classes\class-widget.php .

	// Make sure meta is got for the post, not for its revision.
	if ( wp_is_post_revision( $post_id ) ) {
		$post_parent = get_post_parent( $post_id );
		if ( null !== $post_parent ) {
			$post_id = $post_parent->ID;
		}
	}

	// Get old image data, if any
	// and delete it.
	delete_generated_image( $post_id, get_post( $post_id ) );

	// Bye bye and return the un-modified, new image (data).
	return $poster;
}


/**
 * By default the autogenartion is not done, when just swapping featured-images,
 * because it is not the whole $post that is changed, but only some metadata.
 *
 * So we have another action hooked onto the change of the featured-image meta,
 * which triggers the autogenartion.
 *
 * ---
 *
 * Fires immediately after updating metadata of a specific type.
 *
 * The dynamic portion of the hook name, `$meta_type`, refers to the meta object type
 * (post, comment, term, user, or any other type with an associated meta table).
 *
 * Possible hook names include:
 *
 *  - `updated_post_meta`
 *  - `updated_comment_meta`
 *  - `updated_term_meta`
 *  - `updated_user_meta`
 *
 * @param int    $meta_id     ID of updated metadata entry.
 * @param int    $object_id   ID of the object metadata is for.
 * @param string $meta_key    Metadata key.
 */
function trigger_autogeneration( $meta_id, $object_id, $meta_key ): void {
	if ( '_thumbnail_id' !== $meta_key ) {
		return;
	}

	if ( wp_is_post_revision( $object_id ) ) {
		return;
	}

	// The autogenerate_poster() function will do nothing,
	// as long as an existing set of 'poster' post_meta exists.
	//
	// So we have to delete this at first
	// to make sure this runs properly.
	delete_generated_image( $object_id, get_post( $object_id ) );

	// Generate new poster data using post data.
	( new Generator() )->compose( 
		[
			'template' => 0,
		],
		$object_id,
		'post'
	);
}

/**
 * Delete auto-generated 'Sharing Image's.
 * 
 * Fires before a post is deleted, at the start of wp_delete_post().
 * The 'delete_post' hook is too late, because the relevant post_meta is already deleted.
 *
 * @param  int     $post_id Post-ID of the currently managed post.
 * @param  WP_Post $post    Full WP_Post object.
 *
 * @return void
 */
function delete_generated_image( int $post_id, WP_Post $post ): void {

	if ( ! post_type_supports( $post->post_type, Sharing_Image\POST_TYPE_SUPPORT ) ) {
		return;
	}

	$_sharing_image = get_post_meta( $post_id, Widget::WIDGET_META, true );

	if ( ! \is_array( $_sharing_image ) || ! isset( $_sharing_image['poster'] ) || ! \is_string( $_sharing_image['poster'] ) || ! esc_url( $_sharing_image['poster'] ) ) {
		return;
	}

	$_sharing_image_path = get_path_from_url( $_sharing_image['poster'] );
	if ( empty( $_sharing_image_path ) ) {
		return;
	}

	unlink( $_sharing_image_path ); // phpcs:ignore WordPressVIPMinimum.Functions.RestrictedFunctions.file_ops_unlink
}


/**
 * UNUSED right now
 *
 * [__prepare_text_layer description]
 *
 * @subpackage [subpackage]
 * @version    2022-10-05
 * @author     Carsten Bach
 *
 * @param      string       $layer_name [description]
 * @param      string       $new_text   [description]
 * @return     [type]                   [description]
function __prepare_text_layer( $layer_name = 'title', $new_text = '' ) {
	// which index has this layer
	// in the array of saved layers for this template
	$layer_index = LAYER[ $layer_name ];

	// update data
	$this->site_specific_options[0]['layers'][$layer_index]['sample']  = $new_text;
	$this->site_specific_options[0]['layers'][$layer_index]['content'] = $new_text;

	return $this->site_specific_options;
}
 */

/**
 * Add a new 'Logo' Layer to the 'Sharing Image' template.
 *
 * @param  array<string, array<array<string, string>>> $template List of template data.
 *
 * @return array<string, array<array<string, string>>>
 */
function get_site_logo( array $template ): array {
	// Which index has this layer in the array of saved layers for this template?
	$layer_index = (int) LAYER['logo'];

	// Get site-logo ID.
	$logo = get_option( 'site_icon' );

	if ( empty( $logo ) || ! \is_string( $logo ) ) {
		// The plugin itself checks if 'attachment' isset().
		unset( $template['layers'][ $layer_index ]['attachment'] );
		return $template;
	}
	
	$template['layers'][ $layer_index ]['attachment'] = $logo;
	
	return $template;
}

/**
 * Add color-definitions to existing layers of the 'Sharing Image' template to match the current theme.
 *
 * @param  array<string, array<array<string, string>>|string> $template List of template data.
 *
 * @return array<string, array<array<string, string>>|string>
 */
function get_theme_color( array $template ): array {
	// Get colors from gutenberg.
	$colors = \Figuren_Theater\Theming\Themed_Login\ft_get_relevant_colors();

	// Prepare color options with site-specific stuff, fallback to f.t scheme.
	$template['fill']                                = ( isset( $colors['ft_background'] ) && \is_string( $colors['ft_background'] ) ) ? $colors['ft_background'] : '#0f0b0e';
	$template['layers'][ LAYER['title'] ]['color']   = ( isset( $colors['ft_text'] ) && \is_string( $colors['ft_text'] ) ) ? $colors['ft_text'] : '#fbf9fa';
	$template['layers'][ LAYER['url'] ]['color']     = ( isset( $colors['ft_text'] ) && \is_string( $colors['ft_text'] ) ) ? $colors['ft_text'] : '#fbf9fa';
	$template['layers'][ LAYER['overlay'] ]['color'] = ( isset( $colors['ft_accent'] ) && \is_string( $colors['ft_accent'] ) ) ? $colors['ft_accent'] : '#d20394';

	return $template;
}

/**
 * Set the background-image for the 'Sharing Image' template to match the current posts featured-image.
 *
 * @param  array<string, string> $template List of template data.
 * @param  WP_Post|null          $post     
 *
 * @return array<string, string>
 */
function get_featured_image( array $template, WP_Post|null $post ): array {
	// 0.
	if ( isset( $template['image'] ) && \is_string( $template['image'] ) && esc_url( $template['image'] ) ) {
		return $template;
	}

	// 1.'generate_template()' @ plugins\sharing-image\classes\class-generator.php
	$thumbnail_id = get_post_thumbnail_id( $post );
	if ( ! empty( $thumbnail_id ) ) {
		$template['image'] = get_attached_file( $thumbnail_id );
	}

	return $template;
}

/**
 * Set the URL text of the 'Sharing Image' template 
 * to the shortlink of the given post or the site_url as a fallback.
 *
 * @param  array<string, array<array<string, string>>> $template List of template data.
 * @param  WP_Post|null                                $post     Current Post object.
 *
 * @return array<string, array<array<string, string>>>
 */
function get_shortlink( array $template, WP_Post|null $post ): array {
	// Prepare url.
	$url = null;

	// Get url of current post or site.
	if ( null !== $post ) {
		$url = wp_get_shortlink( $post->ID );
	}

	// Fallback.
	if ( empty( $url ) ) {
		$url = wp_get_shortlink();
	}

	// Still empty ?
	if ( empty( $url ) ) {
		$url = site_url();
	}

	if ( esc_url( $url ) ) {

		// Remove protocoll.
		$url = str_replace( 'https://', '', esc_url( $url ) );

		// Set data.
		$template['layers'][ LAYER['url'] ]['sample']  = $url;
		$template['layers'][ LAYER['url'] ]['content'] = $url;
	}

	return $template;
}

/**
 * Extract an image path from its URL.
 *
 * @param  string $url Full URL to image.
 *
 * @return string      Absolute path to image.
 */
function get_path_from_url( string $url = '' ): string {
		$wp_upload_dir = wp_get_upload_dir();

	$path = str_replace(
		$wp_upload_dir['baseurl'],
		$wp_upload_dir['basedir'],
		$url
	);

	if ( ! file_exists( $path ) ) {
		return '';
	}

	return $path;
}
